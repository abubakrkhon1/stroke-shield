<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Stroke Detection Application using MediaPipe"
    />
    <title>Stroke Detection App</title>
    <!-- Include MediaPipe dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
    <!-- Include Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Include Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
      .detection-container {
        position: relative;
      }
      .detection-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }
      .metric-card {
        background-color: white;
        border-radius: 0.5rem;
        box-shadow: 0 1px 3px rgba(0,0,0,0.12);
        padding: 1rem;
        margin-bottom: 1rem;
      }
      .metric-value {
        font-size: 1.5rem;
        font-weight: bold;
      }
      .metric-label {
        color: #6b7280;
        font-size: 0.875rem;
      }
    </style>
  </head>
  <body class="bg-gray-100 font-sans">
    <header class="bg-blue-600 text-white p-4">
      <div class="container mx-auto">
        <h1 class="text-3xl font-bold">Stroke Detection System</h1>
        <p class="mt-2">Real-time analysis of facial asymmetry and body posture</p>
      </div>
    </header>
    
    <main class="container mx-auto p-4">
      <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <div class="bg-white rounded-lg shadow-lg p-4">
          <h2 class="text-xl font-bold mb-4">Camera Input</h2>
          <div class="detection-container">
            <video id="webcam" autoplay playsinline class="w-full h-auto rounded" style="max-height: 480px;"></video>
            <canvas id="detection-canvas" class="detection-canvas" width="640" height="480"></canvas>
          </div>
          <div class="mt-4 flex gap-2">
            <button 
              id="detection-toggle"
              class="px-4 py-2 rounded font-bold bg-green-500 text-white"
            >
              Start Detection
            </button>
            <button 
              id="clear-results"
              class="px-4 py-2 bg-gray-300 rounded font-bold"
            >
              Clear Results
            </button>
          </div>
          <div class="mt-2 flex flex-wrap gap-2">
            <div class="flex items-center">
              <input type="checkbox" id="face-mesh-toggle" class="mr-2" checked>
              <label for="face-mesh-toggle">Show Face Mesh</label>
            </div>
            <div class="flex items-center ml-4">
              <input type="checkbox" id="pose-toggle" class="mr-2">
              <label for="pose-toggle">Show Pose Detection</label>
            </div>
          </div>
          <div class="mt-2">
            <select id="simulation-mode" class="px-2 py-1 border rounded">
              <option value="normal">Normal Simulation</option>
              <option value="mild">Mild Asymmetry</option>
              <option value="moderate">Moderate Asymmetry</option>
              <option value="severe">Severe Asymmetry</option>
            </select>
            <span class="text-sm text-gray-500 ml-2">Simulation mode for testing</span>
          </div>
        </div>
        
        <div class="bg-white rounded-lg shadow-lg p-4">
          <h2 class="text-xl font-bold mb-4">Detection Results</h2>
          
          <!-- Risk Level Indicator -->
          <div class="mb-6">
            <h3 class="text-lg font-semibold mb-2">Risk Assessment</h3>
            <div id="risk-indicator" class="px-4 py-2 rounded text-white font-bold text-center bg-gray-500">
              Awaiting Analysis
            </div>
          </div>
          
          <!-- Visualization -->
          <div class="mb-6">
            <h3 class="text-lg font-semibold mb-2">Asymmetry Metrics</h3>
            <div class="bg-white rounded-lg p-2 shadow-inner">
              <canvas id="metrics-chart" height="200"></canvas>
            </div>
          </div>
          
          <!-- Metrics Grid -->
          <div class="grid grid-cols-2 gap-4 mb-6">
            <div class="metric-card">
              <div class="metric-label">Eye Asymmetry</div>
              <div id="eye-asymmetry" class="metric-value">N/A</div>
            </div>
            <div class="metric-card">
              <div class="metric-label">Mouth Asymmetry</div>
              <div id="mouth-asymmetry" class="metric-value">N/A</div>
            </div>
            <div class="metric-card">
              <div class="metric-label">Eyebrow Asymmetry</div>
              <div id="eyebrow-asymmetry" class="metric-value">N/A</div>
            </div>
            <div class="metric-card">
              <div class="metric-label">Overall Asymmetry</div>
              <div id="overall-asymmetry" class="metric-value">N/A</div>
            </div>
          </div>
          
          <!-- Posture Metrics -->
          <div class="grid grid-cols-2 gap-4 mb-6">
            <div class="metric-card">
              <div class="metric-label">Shoulder Imbalance</div>
              <div id="shoulder-imbalance" class="metric-value">N/A</div>
            </div>
            <div class="metric-card">
              <div class="metric-label">Head Tilt</div>
              <div id="head-tilt" class="metric-value">N/A</div>
            </div>
            <div class="metric-card">
              <div class="metric-label">Body Lean</div>
              <div id="body-lean" class="metric-value">N/A</div>
            </div>
          </div>
          
          <!-- Findings -->
          <div>
            <h3 class="text-lg font-semibold mb-2">Key Findings</h3>
            <ul id="findings-list" class="list-disc pl-5">
              <li>No findings yet. Start detection to analyze facial asymmetry and posture.</li>
            </ul>
          </div>
          
          <!-- Disclaimer -->
          <div class="mt-6 text-sm text-gray-600 bg-gray-100 p-3 rounded">
            <strong>Disclaimer:</strong> This tool is not a medical device and should not be used for medical diagnosis. 
            If you suspect a stroke, call emergency services immediately (911 in the US). 
            Remember the FAST method: Facial drooping, Arm weakness, Speech difficulties, Time to call emergency services.
          </div>
        </div>
      </div>
    </main>
    
    <footer class="bg-gray-800 text-white p-4 mt-8">
      <div class="container mx-auto text-center">
        <p>Stroke Detection Application - Using MediaPipe and React</p>
        <p class="text-sm mt-2">Disclaimer: This tool is for educational purposes only and not a medical diagnostic device.</p>
      </div>
    </footer>
    
    <script>
      document.addEventListener('DOMContentLoaded', function() {
        const webcamEl = document.getElementById('webcam');
        const detectionCanvas = document.getElementById('detection-canvas');
        const canvasCtx = detectionCanvas.getContext('2d');
        const toggleButton = document.getElementById('detection-toggle');
        const clearButton = document.getElementById('clear-results');
        const faceMeshToggle = document.getElementById('face-mesh-toggle');
        const poseToggle = document.getElementById('pose-toggle');
        const simulationMode = document.getElementById('simulation-mode');
        
        let faceMesh;
        let pose;
        let camera;
        let lastVideoTime = -1;
        let isDetecting = false;
        let showFaceMesh = true;
        let showPose = false;
        
        // Store metrics for smoothing
        let metricsHistory = {
          eyeAsymmetry: [],
          mouthAsymmetry: [],
          eyebrowAsymmetry: [],
          shoulderImbalance: [],
          headTilt: [],
          bodyLean: []
        };
        
        // Default metrics values
        let currentMetrics = {
          eyeAsymmetry: 0,
          mouthAsymmetry: 0,
          eyebrowAsymmetry: 0,
          shoulderImbalance: 0,
          headTilt: 0,
          bodyLean: 0,
          overallAsymmetry: 0
        };
        
        // Max history length for smoothing
        const MAX_HISTORY = 10;
        
        // Update frequency for metrics display (ms)
        const UPDATE_INTERVAL = 500;
        let lastUpdate = 0;
        
        // Initialize metrics chart
        const ctx = document.getElementById('metrics-chart').getContext('2d');
        const metricsChart = new Chart(ctx, {
          type: 'bar',
          data: {
            labels: [
              'Eye Asymmetry', 
              'Mouth Asymmetry', 
              'Eyebrow Asymmetry', 
              'Overall Facial Asymmetry',
              'Shoulder Imbalance',
              'Head Tilt',
              'Body Lean'
            ],
            datasets: [{
              label: 'Asymmetry Metrics (%)',
              data: [0, 0, 0, 0, 0, 0, 0],
              backgroundColor: [
                'rgba(255, 99, 132, 0.6)',
                'rgba(54, 162, 235, 0.6)',
                'rgba(255, 206, 86, 0.6)',
                'rgba(75, 192, 192, 0.6)',
                'rgba(153, 102, 255, 0.6)',
                'rgba(255, 159, 64, 0.6)',
                'rgba(199, 199, 199, 0.6)'
              ],
              borderColor: [
                'rgba(255, 99, 132, 1)',
                'rgba(54, 162, 235, 1)',
                'rgba(255, 206, 86, 1)',
                'rgba(75, 192, 192, 1)',
                'rgba(153, 102, 255, 1)',
                'rgba(255, 159, 64, 1)',
                'rgba(199, 199, 199, 1)'
              ],
              borderWidth: 1
            }]
          },
          options: {
            scales: {
              y: {
                beginAtZero: true,
                max: 100,
                title: {
                  display: true,
                  text: 'Asymmetry (%)'
                }
              }
            },
            animation: {
              duration: 500
            }
          }
        });
        
        // Helper function to get average of array
        function getAverage(arr) {
          if (arr.length === 0) return 0;
          return arr.reduce((a, b) => a + b, 0) / arr.length;
        }
        
        // Add value to metrics history and maintain max length
        function addToHistory(metric, value) {
          if (!metricsHistory[metric]) {
            metricsHistory[metric] = [];
          }
          
          metricsHistory[metric].push(value);
          
          if (metricsHistory[metric].length > MAX_HISTORY) {
            metricsHistory[metric].shift();
          }
          
          return getAverage(metricsHistory[metric]);
        }
        
        // Initialize MediaPipe FaceMesh
        function setupFaceMesh() {
          faceMesh = new FaceMesh({
            locateFile: (file) => {
              return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
            }
          });
          
          faceMesh.setOptions({
            maxNumFaces: 1,
            refineLandmarks: true,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
          });
          
          faceMesh.onResults(onFaceMeshResults);
        }
        
        // Initialize MediaPipe Pose
        function setupPose() {
          pose = new Pose({
            locateFile: (file) => {
              return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;
            }
          });
          
          pose.setOptions({
            modelComplexity: 1,
            smoothLandmarks: true,
            enableSegmentation: false,
            smoothSegmentation: false,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
          });
          
          pose.onResults(onPoseResults);
        }
        
        // Face Mesh results handler
        function onFaceMeshResults(results) {
          if (!isDetecting) return;
          
          canvasCtx.save();
          canvasCtx.clearRect(0, 0, detectionCanvas.width, detectionCanvas.height);
          
          if (results.multiFaceLandmarks && showFaceMesh) {
            for (const landmarks of results.multiFaceLandmarks) {
              // Draw face mesh
              drawConnectors(canvasCtx, landmarks, FACEMESH_TESSELATION, 
                            {color: '#C0C0C070', lineWidth: 1});
              drawConnectors(canvasCtx, landmarks, FACEMESH_RIGHT_EYE, 
                            {color: '#FF3030', lineWidth: 2});
              drawConnectors(canvasCtx, landmarks, FACEMESH_LEFT_EYE, 
                            {color: '#30FF30', lineWidth: 2});
              drawConnectors(canvasCtx, landmarks, FACEMESH_RIGHT_EYEBROW, 
                            {color: '#FF3030', lineWidth: 2});
              drawConnectors(canvasCtx, landmarks, FACEMESH_LEFT_EYEBROW, 
                            {color: '#30FF30', lineWidth: 2});
              drawConnectors(canvasCtx, landmarks, FACEMESH_RIGHT_IRIS, 
                            {color: '#FF3030', lineWidth: 2});
              drawConnectors(canvasCtx, landmarks, FACEMESH_LEFT_IRIS, 
                            {color: '#30FF30', lineWidth: 2});
              drawConnectors(canvasCtx, landmarks, FACEMESH_FACE_OVAL, 
                            {color: '#E0E0E0', lineWidth: 2});
              drawConnectors(canvasCtx, landmarks, FACEMESH_LIPS, 
                            {color: '#E0E0E0', lineWidth: 2});
            }
          }
          
          canvasCtx.restore();
        }
        
        // Pose results handler
        function onPoseResults(results) {
          if (!isDetecting) return;
          
          canvasCtx.save();
          
          if (results.poseLandmarks && showPose) {
            drawConnectors(canvasCtx, results.poseLandmarks, POSE_CONNECTIONS,
                          {color: '#00FF00', lineWidth: 4});
            drawLandmarks(canvasCtx, results.poseLandmarks,
                         {color: '#FF0000', lineWidth: 2});
          }
          
          canvasCtx.restore();
        }
        
        // Generate simulated metrics based on selected mode
        function getSimulatedMetrics() {
          const mode = simulationMode.value;
          const baseNoise = 0.02; // Small amount of noise for variation
          
          let baseValues = {
            eyeAsymmetry: 0.05,
            mouthAsymmetry: 0.05,
            eyebrowAsymmetry: 0.05,
            shoulderImbalance: 0.05,
            headTilt: 0.05,
            bodyLean: 0.05
          };
          
          // Adjust values based on simulation mode
          switch(mode) {
            case 'mild':
              baseValues.eyeAsymmetry = 0.15;
              baseValues.mouthAsymmetry = 0.12;
              break;
            case 'moderate':
              baseValues.eyeAsymmetry = 0.25;
              baseValues.mouthAsymmetry = 0.22;
              baseValues.eyebrowAsymmetry = 0.20;
              baseValues.shoulderImbalance = 0.15;
              break;
            case 'severe':
              baseValues.eyeAsymmetry = 0.35;
              baseValues.mouthAsymmetry = 0.30;
              baseValues.eyebrowAsymmetry = 0.28;
              baseValues.shoulderImbalance = 0.20;
              baseValues.headTilt = 0.25;
              break;
            default: // normal
              // Keep default low values
              break;
          }
          
          // Add small noise to each value for realistic variation
          return {
            eyeAsymmetry: baseValues.eyeAsymmetry + (Math.random() * baseNoise * 2 - baseNoise),
            mouthAsymmetry: baseValues.mouthAsymmetry + (Math.random() * baseNoise * 2 - baseNoise),
            eyebrowAsymmetry: baseValues.eyebrowAsymmetry + (Math.random() * baseNoise * 2 - baseNoise),
            shoulderImbalance: baseValues.shoulderImbalance + (Math.random() * baseNoise * 2 - baseNoise),
            headTilt: baseValues.headTilt + (Math.random() * baseNoise * 2 - baseNoise),
            bodyLean: baseValues.bodyLean + (Math.random() * baseNoise * 2 - baseNoise)
          };
        }
        
        // Update metrics with smoothing
        function updateMetrics() {
          if (!isDetecting) return;
          
          const now = Date.now();
          if (now - lastUpdate < UPDATE_INTERVAL) {
            return; // Only update at the specified interval
          }
          lastUpdate = now;
          
          // Get simulated metrics
          const metrics = getSimulatedMetrics();
          
          // Add to history and get smoothed values
          const smoothedMetrics = {
            eyeAsymmetry: addToHistory('eyeAsymmetry', metrics.eyeAsymmetry),
            mouthAsymmetry: addToHistory('mouthAsymmetry', metrics.mouthAsymmetry),
            eyebrowAsymmetry: addToHistory('eyebrowAsymmetry', metrics.eyebrowAsymmetry),
            shoulderImbalance: addToHistory('shoulderImbalance', metrics.shoulderImbalance),
            headTilt: addToHistory('headTilt', metrics.headTilt),
            bodyLean: addToHistory('bodyLean', metrics.bodyLean)
          };
          
          // Calculate overall asymmetry
          const overallAsymmetry = (
            smoothedMetrics.eyeAsymmetry * 0.4 + 
            smoothedMetrics.mouthAsymmetry * 0.4 + 
            smoothedMetrics.eyebrowAsymmetry * 0.2
          );
          
          // Update current metrics
          currentMetrics = {
            ...smoothedMetrics,
            overallAsymmetry
          };
          
          // Update UI
          document.getElementById('eye-asymmetry').textContent = (currentMetrics.eyeAsymmetry * 100).toFixed(1) + '%';
          document.getElementById('mouth-asymmetry').textContent = (currentMetrics.mouthAsymmetry * 100).toFixed(1) + '%';
          document.getElementById('eyebrow-asymmetry').textContent = (currentMetrics.eyebrowAsymmetry * 100).toFixed(1) + '%';
          document.getElementById('overall-asymmetry').textContent = (currentMetrics.overallAsymmetry * 100).toFixed(1) + '%';
          
          document.getElementById('shoulder-imbalance').textContent = (currentMetrics.shoulderImbalance * 100).toFixed(1) + '%';
          document.getElementById('head-tilt').textContent = (currentMetrics.headTilt * 100).toFixed(1) + '%';
          document.getElementById('body-lean').textContent = (currentMetrics.bodyLean * 100).toFixed(1) + '%';
          
          // Update chart
          metricsChart.data.datasets[0].data = [
            currentMetrics.eyeAsymmetry * 100, 
            currentMetrics.mouthAsymmetry * 100, 
            currentMetrics.eyebrowAsymmetry * 100, 
            currentMetrics.overallAsymmetry * 100,
            currentMetrics.shoulderImbalance * 100,
            currentMetrics.headTilt * 100,
            currentMetrics.bodyLean * 100
          ];
          metricsChart.update();
          
          // Update risk assessment
          updateRiskAssessment();
        }
        
        // Update risk assessment based on current metrics
        function updateRiskAssessment() {
          // Determine risk level based on metrics
          let riskLevel = 'low';
          let riskColor = 'bg-green-500';
          let findings = [];
          
          const LOW_THRESHOLD = 0.1;
          const MEDIUM_THRESHOLD = 0.2;
          const HIGH_THRESHOLD = 0.3;
          
          if (currentMetrics.eyeAsymmetry > HIGH_THRESHOLD || 
              currentMetrics.mouthAsymmetry > HIGH_THRESHOLD || 
              currentMetrics.overallAsymmetry > HIGH_THRESHOLD) {
            riskLevel = 'high';
            riskColor = 'bg-red-500';
            findings.push('Significant facial asymmetry detected');
            
            if (currentMetrics.eyeAsymmetry > HIGH_THRESHOLD) {
              findings.push('High eye asymmetry - possible facial drooping');
            }
            if (currentMetrics.mouthAsymmetry > HIGH_THRESHOLD) {
              findings.push('High mouth asymmetry - possible facial weakness');
            }
            
            findings.push('Multiple high-risk indicators detected. Consider seeking immediate medical evaluation.');
          } else if (currentMetrics.eyeAsymmetry > MEDIUM_THRESHOLD || 
                    currentMetrics.mouthAsymmetry > MEDIUM_THRESHOLD || 
                    currentMetrics.shoulderImbalance > MEDIUM_THRESHOLD || 
                    currentMetrics.overallAsymmetry > MEDIUM_THRESHOLD) {
            riskLevel = 'medium';
            riskColor = 'bg-yellow-500';
            findings.push('Moderate asymmetry detected');
            
            if (currentMetrics.eyeAsymmetry > MEDIUM_THRESHOLD) {
              findings.push('Moderate eye asymmetry detected');
            }
            if (currentMetrics.mouthAsymmetry > MEDIUM_THRESHOLD) {
              findings.push('Moderate mouth asymmetry detected');
            }
            if (currentMetrics.shoulderImbalance > MEDIUM_THRESHOLD) {
              findings.push('Noticeable shoulder imbalance detected');
            }
            
            findings.push('Some concerning asymmetry detected. Consider consulting a healthcare provider.');
          } else {
            findings.push('No significant asymmetry indicators detected at this time.');
            
            if (currentMetrics.eyeAsymmetry > LOW_THRESHOLD) {
              findings.push('Slight eye asymmetry detected (within normal range)');
            }
            if (currentMetrics.mouthAsymmetry > LOW_THRESHOLD) {
              findings.push('Slight mouth asymmetry detected (within normal range)');
            }
          }
          
          findings.push('Remember FAST for stroke: Face drooping, Arm weakness, Speech difficulty, Time to call emergency services.');
          
          // Update risk indicator
          const riskIndicator = document.getElementById('risk-indicator');
          riskIndicator.className = `px-4 py-2 rounded text-white font-bold text-center ${riskColor}`;
          
          if (riskLevel === 'high') {
            riskIndicator.textContent = 'High Risk - Seek Medical Attention';
          } else if (riskLevel === 'medium') {
            riskIndicator.textContent = 'Medium Risk - Consider Medical Consultation';
          } else {
            riskIndicator.textContent = 'Low Risk - Continue Monitoring';
          }
          
          // Update findings list
          const findingsList = document.getElementById('findings-list');
          findingsList.innerHTML = '';
          findings.forEach(finding => {
            const li = document.createElement('li');
            li.textContent = finding;
            li.className = 'mb-1';
            findingsList.appendChild(li);
          });
        }
        
        // Toggle detection button
        toggleButton.addEventListener('click', function() {
          isDetecting = !isDetecting;
          if (isDetecting) {
            startCamera();
            this.textContent = 'Stop Detection';
            this.classList.remove('bg-green-500');
            this.classList.add('bg-red-500');
          } else {
            stopCamera();
            this.textContent = 'Start Detection';
            this.classList.remove('bg-red-500');
            this.classList.add('bg-green-500');
          }
        });
        
        // Clear results button
        clearButton.addEventListener('click', function() {
          // Reset metrics displays
          document.getElementById('eye-asymmetry').textContent = 'N/A';
          document.getElementById('mouth-asymmetry').textContent = 'N/A';
          document.getElementById('eyebrow-asymmetry').textContent = 'N/A';
          document.getElementById('overall-asymmetry').textContent = 'N/A';
          document.getElementById('shoulder-imbalance').textContent = 'N/A';
          document.getElementById('head-tilt').textContent = 'N/A';
          document.getElementById('body-lean').textContent = 'N/A';
          
          // Reset risk indicator
          document.getElementById('risk-indicator').className = 'px-4 py-2 rounded text-white font-bold text-center bg-gray-500';
          document.getElementById('risk-indicator').textContent = 'Awaiting Analysis';
          
          // Reset findings
          document.getElementById('findings-list').innerHTML = '<li>No findings yet. Start detection to analyze facial asymmetry and posture.</li>';
          
          // Reset chart
          metricsChart.data.datasets[0].data = [0, 0, 0, 0, 0, 0, 0];
          metricsChart.update();
          
          // Reset metrics history
          metricsHistory = {
            eyeAsymmetry: [],
            mouthAsymmetry: [],
            eyebrowAsymmetry: [],
            shoulderImbalance: [],
            headTilt: [],
            bodyLean: []
          };
          
          // Reset current metrics
          currentMetrics = {
            eyeAsymmetry: 0,
            mouthAsymmetry: 0,
            eyebrowAsymmetry: 0,
            shoulderImbalance: 0,
            headTilt: 0,
            bodyLean: 0,
            overallAsymmetry: 0
          };
          
          // Clear canvas
          canvasCtx.clearRect(0, 0, detectionCanvas.width, detectionCanvas.height);
        });
        
        // Face mesh toggle
        faceMeshToggle.addEventListener('change', function() {
          showFaceMesh = this.checked;
          if (!showFaceMesh) {
            // Clear the canvas if needed
            if (!showPose) {
              canvasCtx.clearRect(0, 0, detectionCanvas.width, detectionCanvas.height);
            }
          }
        });
        
        // Pose toggle
        poseToggle.addEventListener('change', function() {
          showPose = this.checked;
          if (!showPose) {
            // Clear the canvas if needed
            if (!showFaceMesh) {
              canvasCtx.clearRect(0, 0, detectionCanvas.width, detectionCanvas.height);
            }
          }
        });
        
        // Simulation mode change
        simulationMode.addEventListener('change', function() {
          // Reset metrics history when changing simulation mode
          metricsHistory = {
            eyeAsymmetry: [],
            mouthAsymmetry: [],
            eyebrowAsymmetry: [],
            shoulderImbalance: [],
            headTilt: [],
            bodyLean: []
          };
        });
        
        function startCamera() {
          setupFaceMesh();
          setupPose();
          
          if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
            navigator.mediaDevices.getUserMedia({ video: true })
              .then(function(stream) {
                webcamEl.srcObject = stream;
                
                // Set up camera utilities
                camera = new Camera(webcamEl, {
                  onFrame: async () => {
                    canvasCtx.clearRect(0, 0, detectionCanvas.width, detectionCanvas.height);
                    
                    if (showFaceMesh) {
                      await faceMesh.send({image: webcamEl});
                    }
                    
                    if (showPose) {
                      await pose.send({image: webcamEl});
                    }
                    
                    // Update metrics
                    updateMetrics();
                  },
                  width: 640,
                  height: 480
                });
                
                camera.start();
              })
              .catch(function(error) {
                console.error('Could not access the camera: ', error);
                alert('Could not access the camera. Please check your permissions.');
                
                // Fall back to simulation if camera fails
                simulateDetection();
              });
          } else {
            alert('Your browser does not support camera access. Please try a different browser.');
            
            // Fall back to simulation if camera not supported
            simulateDetection();
          }
        }
        
        function stopCamera() {
          if (camera) {
            camera.stop();
          }
          
          if (webcamEl.srcObject) {
            webcamEl.srcObject.getTracks().forEach(track => track.stop());
            webcamEl.srcObject = null;
          }
          
          // Clear canvas
          canvasCtx.clearRect(0, 0, detectionCanvas.width, detectionCanvas.height);
        }
        
        function simulateDetection() {
          // For environments where camera is not available
          if (!isDetecting) return;
          
          updateMetrics();
          
          // Continue simulation if still detecting
          if (isDetecting) {
            requestAnimationFrame(simulateDetection);
          }
        }
      });
    </script>
  </body>
</html>
